# 概述
这本书主要讲述了关于Unix系统的发展历史，Unix的文化，Unix系统内部的编程技术，Unix的软件设计思想。虽然这本书距离现在已经有些年头了，但是书中还是有许多值得学习的地方，即使不是Unix软件编程人员。

# 中心思想
我认为这本书的中心思想是把编程视为艺术，而这个艺术的核心就是：简洁与美。  
通过讲述Unix的各个设计思想以及多个相关软件实例，来带领大家深入理解编程的艺术：模块化、简洁性、可读性，体会编程的美。  
引用书中的Unix核心原则来概括这本书的中心思想：Keep It Simple,Stupid。无论是从用户界面、软件设计还是程序代码，尽量保持程序的简洁，用追求艺术的态度来编程。

# 每章小结
## 一.哲学
这是这本书的第一章，介绍了Unix在操作系统发展历史中的优势与劣势，并统一概述的软件编程中的各个原则以及简要介绍原则的内容。  

### Unix得与失
Unix系统与其他的操作系统比较起来，Unix是开发人员设计给其他技术人员使用的一种系统，它讲究策略（目的）与机制（实现）分离，在Unix中提供了许多的机制、各个灵活的可选项来给系统的使用人员，使用人员可以自己给操作系统设计软件，这里的策略是指目标，机制则是达到这个目标的实现过程。因此Unix在技术人员中非常受欢迎，广泛应用于服务器、超级计算机等处。  
然而过于灵活的机制，也导致Unix失去了非技术的用户，当用户设定好了策略，可以自己选择机制时，也意味这用户必须要自己选择机制，而Unix中五花八门的接口、命令等会导致用户趋向于选择更简洁的操作系统。  
但是，从长远来看，用户的策略相对而言更容易发生改变，而机制则相对来说更为稳定，有许多被束缚在同一套机制与界面中的操作系统已经消失在历史的长河，而Unix系统的流传至今。



### Unix哲学原则  
- Keep It Simple,Stupid  
KISS原则：保持简单与愚蠢。把这个原则排在第一位是因为这个原则是本书作者认为可以直接代表整个Unix编程哲学。这个原则旨在让事物容易理解、使用、维护，过度复杂的设计会增加出错的概率，降低可维护性和易用性。在软件编程方面，则意味着开发人员应当尽量采用简单直接的方法来解决问题，避免不必要的复杂性、重复、冗余，提高软件的可读性、可维护性、可扩展性。  
- 模块原则：使用简洁的接口来拼合简单的部件  
计算机的本质就是控制复杂度。要编制复杂的软件而又不至于一败涂地，唯一的解决方法就是降低整体复杂度：用清晰的接口把简单的模块组合成一个复杂的软件（无论是）。如此一来，多数的问题只会被限制在一个小的局部，以及对局部进行改造也不至于牵一发而动全身。  
从项目管理上看模块化还可以更好的拆分工作量，更好的促进团队协作，提升开发效率。  
- 清晰原则：清晰胜于技巧  
编程中，需要记住：我们写的代码并不是给计算机看的，而是给人看的，包括自己以及以后可能会维护这份代码的人。如果为了取得一点点的性能提升，而导致软件复杂度大幅提高、代码晦涩难懂，不仅仅容易滋生bug，日后的阅读和维护也更为艰难。  
- 组合原则：设计时考虑拼接组合
该原则旨在提倡分离不同职责的程序，程序与程序之间通过有效的通信来组合，从而降低软件复杂度。  
在程序的通信方面，unix极度提倡使用文本流来进行通信，文本流最大的好处就是简洁与通用，程序将一个文本流处理成另一个文本流。而且如果需要组合程序，那么就需要保持程序的独立性，程序的输入与输出，尽量不去考虑另一端的程序。  
如果一个程序不能分离成不同的子程序，那么至少也应当编写一套API，将API链接调用来组合程序。
- 分离原则：策略与机制分离、接口与引擎分离  
首先明确原则中出现的名词的含义：  
  - 策略：指一个通用的逻辑过程，是一个比较高层的目标。比如排序、搜索等比较通用的概念。
  - 机制：指实现一个策略的具体实现过程。比如我们要实现排序这一策略，可以选择用冒牌排序来实现。具体的实现就是机制。
策略与机制分离就是将实现特定功能的逻辑与具体的实现分离。比如我们想对数组进行排序，我们可以选择不同的机制来达到策略。  
  - 接口：在软件系统中，让外界与系统进行交互的地方称为接口，比如UI界面、API等。  
  - 引擎：一个系统处理逻辑的实现，比如系统内的数据结构、算法等。
接口与引擎分离就是用户界面与系统实现分离，将用户界面与业务逻辑解耦，两边可以独立修改，提升软件的可维护性，可扩展性。比较常见的web应用的前后端分离也体现了该原则的作用。  
- 简洁原则：设计要简洁，复杂度能低就低  
程序员往往会以玩转复杂的东西和非常抽象的概念为傲，但是往往过度的复杂导致软件臃肿不堪、bug极多，最后只会走向失败。程序员应当以简洁为美。  
- 吝啬原则：除非却无它法，不要编写庞大的程序  
这里的庞大是指，程序体积大（可以简单理解成代码行数），复杂程度大。  
- 透明性原则：设计要可见，以便审查和调试  
有效减少程序的调试时间的方法之一就是设计时充分考虑透明性与显见性。透明性是指一眼就可以看出系统在做什么以及怎么做的。同时显现性指程序带有监视和现实内部状态的功能，这样程序不仅能运行良好，而且还能看得出来程序在如何运行。  
- 健壮原则：健壮源于透明与简洁  
软件的健壮性指软件不仅能在正常情况下运行良好，而且在超出设计者设想的意外条件下也能够运行良好。  
大多数软件毛病多，经不起磕碰，主要原因就是过于复杂，很难从全方面的考虑问题。想让程序健壮，主要有两个方法：透明与简洁。  
软件的透明可以帮助我们一眼就能看出程序是怎么回事。而如果人们不需要较劲脑汁就可以推断出所有的可能的情况，那么这个程序就是简洁的。程序越简洁就越透明也就越健壮。  
另外模块性也可以帮助程序变得更为简洁。  
- 表示原则：把知识叠入数据以求逻辑质朴而健壮  
让人类来验证程序逻辑是比较困难的，但是如果是很复杂的数据，对人类来说还是比较容易能够推导和建模的。  
是以一个Map来进行数据转换更清晰还是写50行的switch语句清晰呢？想必一定是Map吧。数据要比编程逻辑更容易驾驭，在设计中，应当主动把代码的复杂度转移到数据之中。  
- 通俗原则：接口设计避免标新立异  
这个原则也称为最少惊奇原则。最容易使用的程序就是用户需要学习新东西最少的程序。接口设计上应该避免毫无缘由的标新立异。比如设计一个计算机程序“+”号应当永远表示加法，尽量按照用户最熟悉的同样功能接口来进行设计。  
- 缄默原则：如果一个程序没什么好说的，就保持沉默  
将用户的注意力视为一种宝贵的资源，如果程序没有什么好输出的，那么就应当保持沉默。  
- 补救原则：当软件出现异常时，马上退出并给出足量的错误信息  
软件发生错误时，最理想的情况是软件能够应付这种非正常操作，并继续保持良好的运作。但是如果补救措施不成功，那么不应当让程序继续运行，尽可能以容易诊断错误的方式终止。  
许多框架的fail-fast机制，也是尽可能早的停止程序并将错误信息输出。  
- 经济原则：宁化机器一分，不花程序员一秒  
在如今，机器的硬件配置价格已经非常低价，大多数应用场合都应该采用Per、Java这类可以自动管理内存的语言，解放程序管理内存的负担  
- 生成原则：避免手动编码，尽量编写程序去生成程序  
人并不擅长去做辛苦的细节工作，手工的去处理一些文件程序，很容易滋生错误，而由程序生成代码总是比手写代码更值得信赖。  
- 优化原则：雕琢之前得先有原则，跑之前先学会走  
做好原型设计可以帮助我们避免为蝇头小利而投入过多时间。先设计一个未优化的、运行缓慢、很耗内存但是正确的实现，然后在进行系统调整，寻找那些可以牺牲最小的局部简洁性而获得较大性能提升的地方。  
- 多样原则：决不相信所谓“不二法门”的断言  
不要相信任何的“不二法门”
- 扩展原则：设计着眼于未来，未来总是比预想快
尽量在设计时，留下可以扩展的空间。比如稍微增加一些自描述性的开销，就可以在无需破坏原有整体的情况下进行扩展。如在接口中版本号、文件名中增加后缀之类自描述。


### Unix哲学一句话总结
一个程序只做一件事，并做好。程序之间要可以协作。程序要可以处理文本流，这是最通用的接口。  
应用到java中，我的理解是这样：一个接口、一个类、一个模块、一个微服务都只做它职责范围内的事，即单一职责原则。各个模块之间通过互相协作来实现整体软件的目的，各个模块之间的通信由文本来进行传输。  
还有以追求艺术的态度来编程。

## 二.Unix历史
忘记过去的人，注定重蹈覆辙。这一章回顾了Unix的发展历史，了解一个软件的发展历程也许会对我们未来设计软件带来帮助。Unix系统诞生于1970年，最初由汇编语言和B语言编写，而后又使用了C语言重写，使用高级语言来改造对于Unix的广泛传播功不可没，操作系统代码的可读性、可维护性、可移植性都有了巨大的提升。Unix系统在经过广泛发展也离不开其开源代码，在技术界有许多人研究Unix并改造Uix。而后Unix引起了许多商业公司的注意，由商业公司经手改造并收购版权等操作后，Unix此时已接近闭源，再加上Windows系统Mac系统的竞争，Unix系统开始走向没落。而后Linux系统横空出世，Linux系统继承了Unix系统的设计思想、编程风格并且开源，对世界产生了巨大的影响。最后总结一下Unix发展规律：离开源越近，Unix越繁荣；离开源越远，越衰弱。

# 总结
