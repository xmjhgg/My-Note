# K8S初步总结





## k8s概述

kubernetes，简称K8s，是用8 代替8 个字符“ubernete”而成的缩写

通过Kubernetes 能够进行应用的自动化容器部署、容器应用维护、扩缩容、更新升级、回滚等操作。在k8s中会将组成应用的容器组合成一个逻辑单元，用来更方便的管理应用



### K8S架构

k8s架构图：

![1](D:\documentary\组件学习文档\k8s\img\1.jpg)

### k8s架构内组件说明

k8s的使用可以分为两部分：

- 部署容器

  这一部分就是我们通过命令行去执行的，也就是通过命令行的敲kubectl去执行，对应图上Master上的kubectrl

- 外界用户访问k8s内的容器

  这一步则是我们部署好了k8s后,k8s帮我们自动做的，包括负载均衡、代理、主从容灾等，对应图上worker node上Internet访问



#### Master(主控节点)

![2](D:\documentary\组件学习文档\k8s\img\2.jpg)

Master的职责就是管理整个k8s的集群

- API Server：k8s集群的统一入口，提供认证、授权、访问控制、API注册和发现等功能
- Scheduler：节点的调度，选择node节点应用部署
- Controlle（controller-manager）：处理集群中常规后台任务，一个资源对应一个controller
- etcd：存储系统，用于保存集群中的相关数据

#### node（工作节点）

Worker的职责是真正负责执行我们部署的容器

<img src="D:\documentary\组件学习文档\k8s\img\3.jpg" alt="3"  />

- kubelet：kubelet 是在每个 Node 节点上运行的主要 “节点代理”，负责向master的API Server发起注册，管理本机容器的Pod
  - 一个集群中每个节点上运行的代理，它保证Pod中的容器都在期望的规范下运行，并定期向API Server汇报主机的运行状况
  - 负责维护容器的生命周期
- kube-proxy:Kube-proxy负责对Pod进行网络代理，实现了Kubernetes Service 概念的一部分 。它的作用是使发往 Service 的流量（通过ClusterIP和端口）负载均衡到正确的后端Pod。





## k8s的核心概念

### Pod

Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。

Pod最主要的设计意义是为了让一组需要经常通信的容器可以快速的访问而设计，比如一个聊天室应用，消息接收方和发送方需要频繁的网络访问，这时，将这两方放入同一个Pod中，就可以自由的进行访问。



通常我们不会直接创建Pod，而使用如Deployment或Job这类工作负载资源 来创建 Pod。



#### Pod的重启机制

如果Pod中的某个容器出问题了，就会触发Pod的重启机制

Pod有三种重启策略

- Always：当容器终止退出后，总是重启容器，默认策略 【nginx等，需要不断提供服务】
- OnFailure：当容器异常退出（退出状态码非0）时，才重启容器。
- Never：当容器终止退出，从不重启容器 【批量任务】

#### 健康检查

有的时候，程序可能出现了 **Java** 堆内存溢出，程序还在运行，但是不能对外提供服务了，这个时候pod还显示正常运行

### Volume（数据挂载）

由于Pod中的数据在pod被销毁后就没有了，所以我们需要一个技术来持久保存Pod内的数据，就是将pod内的数据同步的保存到真实的主机上

- 声明在Pod容器中可访问的文件目录
- 可以被挂载到Pod中一个或多个容器指定路径下
- 支持多种后端存储抽象【本地存储、分布式存储、云存储】



### Controller、Workload(控制器、工作负载)

> 官网对控制器功能的生活化形容：
>
> 房间里的温度自动调节器。当你设置了温度，告诉了温度自动调节器你的*期望状态（Desired State）*。 房间的实际温度是*当前状态（Current State）*。 通过对设备的开关控制，温度自动调节器让其当前状态接近期望状态。

在 Kubernetes 中，控制器通过监控k8s集群的公共状态，并致力于将当前状态转变为期望的状态。

一个控制器至少追踪一种类型的 Kubernetes 资源。这些对象有一个代表期望状态的 `spec` 字段。 该资源的控制器负责确保其当前状态接近期望状态。



控制器是一个抽象的概念，在k8s中具体控制器（工作负载）有以下5种（我们也可以自己来实现一个新的控制器，比较难）

- Deployment

  用于部署无状态应用

  具有上线部署、副本设定、滚动升级、回滚等功能

  **应用场景: web 服务等**

  - 无状态：
    - deployment认为所有的它控制的pod都是一样的
     - 不用考虑pod启动顺序的要求
     - 不用考虑在哪个node节点上运行
     - 可以随意扩容和缩容

- StatefulSet

  用于部署有状态应用

  控制Pod的生命周期，保证Pod启动顺序和唯一性

  提供滚动更新、回滚，有序的部署和扩展等

  应用场景：各种互相依赖的微服务或有主从关系的组件等

  - 有状态：
    - pod和pod之间是不同的
    - 需要控制启动顺序等（如Mysql主从，需要先启动主后启动从）
    - 需要考虑到网络等因素（需要考虑在哪个Node上运行）

- DaemonSet

   确保全部（或者某些）节点上运行一个 Pod 的副本。当有节点加入集群时，也会为他们新增一个 Pod 。 

  当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。

  **应用场景：**

  - 在每个节点上运行集群守护进程
  - 在每个节点上运行日志收集守护进程
  - 在每个节点上运行监控守护进程

- Job

  Job 会创建一个或者多个 Pods，如果不是第一次创建Job那么第二次执行的Job会继续重试 Pods 的执行，直到指定数量的 Pods 成功终止。 

  如果 Pods 成功结束，Job会 跟踪记录成功完成的 Pods 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pods。 

  挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。

  **应用场景：一次性执行的任务：离线数据分析、视频解码等**

- CronJob

  CronJob用于执行周期性的动作，通过Cron表达式来指定执行的时间

  **应用场景：周期性任务：通知，备份等**

### Service

将运行在一组Pods上的应用程序公开为网络服务的抽象方法

比如在多个Pod上运行多个相同的web服务，那么其他的服务需要访问我们的web服务，要怎么进行访问，又不能告诉对方IP地址和端口（每次pod启动Ip地址由k8s随机分配），也不知道要应该要访问哪个web服务，Service的作用就是提供一个类似域名的功能，提供一组Pods的公共访问方式

#### Service和Pod如何关联

Service和一组pods通过 **Label**关联，有和Service相同Lable的Pod会交由Service来提供访问，Service可以进行负载均衡等操作

- Label

  k8s中的标签，用于资源对象的查询，筛选

#### 

