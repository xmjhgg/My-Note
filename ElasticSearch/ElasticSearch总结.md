# ES的基本概念
## ES存储架构图
![](./img/物理存储架构图.jpg)

## 基本名词解释
- 文档（document）  
  - ES中的数据使用JSON的形式存储，每一个JSON数据称为文档（对应Mysql的每一行数据）  
  - 因为是用采用JSON形式存储，所以ES的文档支持动态的给文档增加新的字段（不需要像Mysql需要先写ddl语句去修改表结构）
  - ES默认给文档中的每个字段都建立索引，如果想节约空间，可以手动来设置索引  
  - 文档字段如果是字符串类型，ES默认不支持字符串类型字段的聚合操作，因为会消耗大量内存。所以ES会自动给字符串类型的字段增加一个keyword类型的子文档，keyword类型的字段可以进行聚合
  - 文档的type属性：在5.0之前索引中的文档可以支持多个不同的type，6.0之后只支持type=_doc。5.0之前支持设置不同的type是为了可以将一个索引当成库使用，不同的type作为不同的表来使用，后来ES官方认为这是一个不好的设计，因为索引已经是一个比较小的单位，将不相关的文档放在同一个索引中不合适，因此ES官方后续偏向于废弃type属性，但是目前还有保留
- 文档映射(mapping)  
  - mapping中记录了一个ES索引中的文档字段名称和字段值的类型，以及这个字段要使用到的分词器、过滤器等
  - 当插入一个新的文档时，ES会自动识别字段值的类型并添加到文档映射中，字段类型在被记录到文档映射中后，就不能更改了，只能通过重建索引(reindex)的方式来进行修改  
- 索引(index)  
  索引在ES中就是一张表，文档就是存储在索引中，ES支持给索引起一个别名，可以将多个索引视为一个索引
- 分片(shared)  
  - 一个分片中会存储一个索引的部分文档，索引在被创建时可以指定需要几个分片，索引中的每一个文档会根据文档的id hash到不同的分片中（类似于分库分表），hash算法是 hash(id) % 分片数量，因此索引在创建后分片的数量就不可以修改，否则同一个文档会因为分片数量变化导致hash值改变而出现在分片上查找不到的问题
  - 分片又分为主分片与副本分片，ES服务正常的情况下只会使用主分片，副本分片是作为高可用的一个保障，同一个分片的主分片与副本分片是不会存放在同一个节点上，当一个主分片所在的节点出现故障时，其他节点上这个分片的副本分片就会升级为主分片来使用
  - 由于一个索引的分片可以被存储到不同的节点上，这样的分布式存储有时候会为搜索、聚合带来一部分的问题（大部分有解决方法），如果我们在创建索引时，指定索引的分片数量是1，那么所有的数据都会存储在同一个分片上，可以规避一些分布式存储带来的问题，但是这样做也会失去分布式存储的优势
- 节点(node)  
一个ES节点就是一台服务器，当一个接收到某个文档的增删改请求时，如果这个文档经过hash后算出的分片不在这个节点上，这个节点会将这个请求转发给存储这个分片的节点
- 集群(cluster)  
一个ES集群中由多个es节点组成，客户端在访问集群时，可以通过一个代理服务器将集群当成一个服务使用


# ES的基础使用
客户端通过restfulAPI来对服务端进行操作 
## 增加
- 指定文档id  
```txt
put /index/type/id
{
    "name":"张三",
    "age":"18"
}
```
- 自动生成文档id
```txt
{
    "name":"李四",
    "age":"20"
}
```
- bulk 批量增加
  ```txt
  POST /index/type/_bulk
  { "index":{ "_id": "8a78dhkujg" } } }
  { "name":"john doe","age":25 }
  { "index":{} }
  { "name":"mary smith","age":32 }
  ```  
  在index中可以指定增加文档的id，也可以指定要插入的索引、type
## 更新
- 更新整个文档  
    ```txt 
    put /index/type/id
    {
        "name":"张三",
        "age":"19"
    }
    ```
    这种方式会直接将原来的文档修改成请求中的数据
- 部分更新
    ```txt
    post /index/type/id/_update
    {
        "doc":{
            "age":"20",
            "sex":"男"
        }
    }
    ```
    这种方式只会修改请求中涉及的字段，如果文档中不存在请求中的字段，则会添加字段到文档中



## 删除
```txt
delete /index/type/id
```
## 查询
### 精确查询(term)
```txt
post /index/_search
{
    "query":{
        "term":{
            "fieldName":fieldValue
        }
    }
}
```
term查询会查找出匹配字段fieldName中等于fieldValue的文档  

- 注意：  
  如果fieldValue这个字段有使用分词器等操作（ES默认会对字符串类型的字段进行分词），那么term查询则匹配的是分词后的结果  
  - 如，文档字段name = 李四，默认分词会将中文拆分成单独的字，也就是 [李、四]，此时term查询 name = 李，也可以查询出此文档  

  如果想对字符串字段做精确查询，可以设置字段为禁用分词器(not_analyze)或者使用keyword类型的字段来存储字符串
### 多个精确值的包含查询(terms)
```txt
post /index/_search
{
    "query":{
        "terms":{
            "fieldName":[fieldValue1,fieldValue2]
        }
    }
}
```
terms类似于 Mysql中的in，会将包含在数组内的文档都查出来
### 匹配查询(match)
```txt
post /index/_search
{
    "query":{
        "match":{
            "fieldName":fieldValue1
        }
    }
}
```
match会对字段分词后的结果进行匹配，查询条件中的值如果在分此后的内容中有出现，则会按照相关度排序后到结果集中
- 如match查询 name = 李五，索引中存在name=李五、name=李四的两个文档，并对name字段使用了默认的分词器将中文拆分为单独的字，此时的match查询会把这两条数据都查询出来，李五这条文档会排在李四之前，并且文档的相关度评分会比李四高  
- 如果字段没有经过分词器处理，那么match可以等价于term
### 范围查询(range)
```txt
post /index/_search
{
    "query":{
        "range":{
            "fieldName":{
                "gte":0,
                "lte":100
            }
        }
    }
}
```
range查询可以用于针对某字段做范围查询
- gt: > 大于（greater than）
- lt: < 小于（less than）
- gte: >= 大于或等于（greater than or equal to）
- lte: <= 小于或等于（less than or equal to）  

如果字段是日期类型，那么range也可以支持这样的查询
```txt
post /index/_search
{
    "query":{
        "range":{
            "fieldName":{
                "gte":"2022-2-10 00:00:00",
                "lte":"2022-2-11 23:59:59"
            }
        }
    }
}
```
### 分页(from+size)
```txt
post /index/_search
{
    "query":{
        "match_all":{}
    },
    "from":5,
    "size":10
}
```
- size表示要获取的结果集的大小
- from则是从匹配到的查询结果的第几条开始获取  

对于一些带有查询条件的聚合请求，只需要聚合后的结果，而不需要文档的内容，可以将size设置为0，减少文档数据的网络传输

### 字段是否存在查询(exists)
```txt
post /index/_search
{
    "query":{
        "exists":{
            "field":"fieldName"
        }
    }
}
```
### 组合查询(bool)
```txt
post /index/_search
{
	"query": {
		"bool": {
			"must": [
				{
				    "exists":{
				        "field":"age"
				    }
				},
				{
				    "range":{
				        "age":{
				            "gte":18
				        }
				    }
				},
				{
				    "match":{
				        "name":"李五"
				    }
				}
			],
			"must_not":[
			    {
			        "exists":{
			            "field":"sex"
			        }
			    }
			],
            "should":[
                {
                    "exists":{
                        "field":"addrss"
                    }
                }
            ]
		}
	}
}
```
bool提供了复杂查询的支持，可以同时使用多个查询条件来匹配数据
- must表示必须满足内部的查询条件
- must_not表示必须不满足内部的查询条件
- should是有满足条件则在结果集的排名更靠前（可以提高文档的相关度评分）
  
上面三个查询内部可以再嵌套bool查询以满足更复杂的查询
### 评分查询与过滤查询
ES中的查询分为两种：评分查询、过滤查询

#### 相关度评分
ES默认使用的查询方式就是评分搜索，也就是在查询文档时，除了文档需要满足查询条件外，还需要去给这个文档和搜索条件之间的关联度进行评分，评分后还要对结果集进行排序，评分结果会放入到_score字段，这个结果就是相关度评分  

#### 两者性能差距
过滤查询（Filtering queries）只是简单的检查包含或者排除，这就使得计算起来非常快。考虑到至少有一个过滤查询（filtering query）的结果是 “稀少的”（很少匹配的文档），并且经常使用不评分查询（non-scoring queries），结果会被缓存到内存中以便快速读取，所以有各种各样的手段来优化查询结果。

相反，评分查询（scoring queries）不仅仅要找出匹配的文档，还要计算每个匹配文档的相关性，计算相关性使得它们比不评分查询费力的多。同时，查询结果并不缓存。
#### 如何使用过滤查询
在查询请求中指定当前查询使用过滤上文下，es就会使用过滤查询来执行此次查询
```txt
post /index/_search
{
    "query" : {
        "constant_score" : { 
            "filter" : {
                "term" : { 
                    "field" : fieldValue
                }
            }
        }
    }
}
```
## 聚合
### 聚合相关名词解释
- 桶  
  桶就是满足特定条件的文档的集合（分组），类似于mysql中的group by sex  
  桶可以再嵌套一个桶，例如按照性别分桶后再按照年龄分桶  
  - 分桶注意事项（terms）  
    当需要根据某个字段分桶时，ES默认不允许对字符串类型的字段进行分桶，主要原因是ES担心字符串的字段非常大，会消耗大量内存与计算资源，因此如果要对字符串类型字段进行分桶，可以改为keyword类型。  
    如果不想调整为keywor类型，需要开启该字段的fielddata，ES会将这些字符串数据缓存到内存中，提高查询效率，开启了fielddata后，需要注意ES的内存消耗，fielddata内的数据在加载后只有根据最近最少使用策略来淘汰，也就是说一旦数据加入到fielddata后，供查询和聚合使用的内存就固定会减少这些数据大小，可以通过indices.fielddata.cache.size来限制fielddata的可以占用的内存空间大小
- 指标  
  桶将文档分到有意义的集合中，指标则是通过一些数学计算得到我们需要的文档计算结果  
  如计算男性用户有多少个人，类似于mysql中的 count(id)
### 总数
在ES中获取文档的总数有两种方法
- count API  
     ```txt
    post /index/_count
    {
	"query":{
	    "match_all":{}
	    }
    }
     ``` 
    这种方式可以查询出符合条件的文档总数
- 分桶后返回的doc_count(terms)
    ```txt
    post /index/_search
    {
	    "size": 0,
	    "aggs": {
		    "ageBucket": {
			    "terms": {
				    "field": "age.keyword"
			    }
		    }
	    }
    }
    ```
### 求和
### 平均
### 最大、最小
### 状态统计

# ES的数据结构
## 倒排索引

## 词典

# ES的分布式搜索过程
## 分布式的查询
## 分布式的聚合

# ES的高阶使用
## es脚本
## 分词器
## 过滤器
## 高级搜索
## 聚合
## 提高相关性
## 建议

# ES的数据建模
# ES集群监控管理